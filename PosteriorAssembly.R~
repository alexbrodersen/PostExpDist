rm(list = ls())
gc()
library(lpSolve)
library(Rcpp)
setwd("~/Documents/Projects/PosteriorExposureDistribution/")
list.files()
sourceCpp("FisherInfo.cpp")
sourceCpp("Probs3plm.cpp")
sourceCpp("")
system(". $HOME/.bashrc")
system("echo $PATH")
nItems <- 1500
nForms <- 5
nMidpoints <- 20

mLength <- 30
nForms*nMidpoints*mLength/2

10/(nForms*nMidpoints)
a <- rlnorm(nItems,0,.2)
b <- rnorm(nItems)
c <- rep(0,nItems)

edges <- qnorm(seq(0,1,length.out = (nMidpoints + 1))[2:(nMidpoints)])

lb <- -4
ub <- 4
CalcMidpoints <- function(points,lb,ub){
    x <- c(lb,points,ub)
    y <- NULL
    for(i in 1:(length(x) - 1)){
      y[i] <- (x[i] + x[(i + 1)])/2        
    }
    return(y)
}

midPoints <- CalcMidpoints(edges,lb,ub)



x <- NULL
for(i in 1:nMidpoints){
x <- c(x,rep(FisherInfo(theta = midPoints[i],a = a, b = b, c = c),nForms))
}

makeLengthCon <- function(nItems,nForms,nMidpoints){
    mat <- matrix(0,nrow = nForms*nMidpoints, ncol = nItems*nForms*nMidpoints)
    for(i in 1:(nForms*nMidpoints)){
        mat[i,(1 + (i - 1)*nItems):(i*nItems)] <- 1
    }
    return(mat)
}

makeItemLimits <- function(nItems,nForms,nMidpoints){
    mat <- NULL
    for(i in 1:(nForms*nMidpoints)){
        mat <- cbind(mat,diag(nItems))
    }
    return(mat)
}

f.obj <- x
out <- makeItemLimits(nItems,nForms,nMidpoints)
out2 <- makeLengthCon(nItems,nForms,nMidpoints)


f.con <- rbind(out2,out,out)
rm(out,out2)
gc()
f.rhs <- c(rep(mLength,nForms*nMidpoints),rep(3,nItems),rep(1,nItems))
f.dir <- c(rep("==",nForms*nMidpoints),rep("<=",nItems),rep(">=",nItems))
dim(f.con)
length(f.dir)
length(f.rhs)

ft <- lp(direction = "max",objective.in = f.obj, const.mat = f.con,
          const.dir = f.dir,const.rhs = f.rhs,all.bin = TRUE)

ft
gc()
rrr <- trimSolution(ft,nItems,nForms,nMidpoints)
table(unlist(rrr))

trimSolution <- function(ft,nItems,nForms,nMidpoints){
    testList <- list()

    for(i in 1:nMidpoints){
        testList[[i]] <- list()
    }

    for(i in 1:nMidpoints){
        for(j in 1:nForms){
            counter <- j + nForms*(i - 1)
            print(counter)
            testList[[i]][[j]] <- which(ft$solution[(1 + (counter - 1)*nItems):(counter*nItems)] == 1)
        }
    }
    return(testList)
}

MAP <- function(irvs,a,b,max.it=50,HPM =  0, HPVAR = 1,initTheta = 0){
    theta <- initTheta
    U <- irvs # response vector
    n.items <- length(U)
    
    BIGT <- .5 # delta
    for(i in 1:max.it){
        sum.dem <- 0
        sum.num <- 0
        for(j in 1:n.items){
            deviation <- a[j]*(theta-b[j])
            p.hat <- 1/(1 + exp(-deviation))
            WIJ <- p.hat*(1-p.hat)
            VIJ <- (U[j]-p.hat)
            sum.num <- sum.num + a[j]*VIJ
            sum.dem <- sum.dem + a[j]*a[j]*WIJ
        }
        sum.num <- sum.num - (theta-HPM)/HPVAR
        sum.dem <- -sum.dem-(1/HPVAR)
        delta <- sum.num/sum.dem
        if(abs(delta)>BIGT){
            if(delta > 0){
                delta <- BIGT
            } else {
                delta <- -BIGT
            }
        }
        theta <- theta - delta
        if(abs(delta) < .01){
            break
        }
    }
    return(theta)
}
length(rrr)

CatSim <- function(thetas,a,b,c,mLength,edges,nForms,rrr,method){
    n <- length(thetas)
    theta.hat <- rep(0,n)
    edges <- c(-Inf,edges,Inf)
    I <- matrix(NA,n,mLength)
    U <- matrix(NA,n,mLength)
    theta.out <- matrix(NA,n,mLength)
    for(i in 1:n){
        print(i)
        for(j in 1:mLength){

            if(method == "MaxInfo"){                
                info <- FisherInfo(theta.hat[i],a,b,c)
                infoMat <- cbind(t(info),1:length(info))
                items <- na.omit(I[i,])
                if(length(items) != 0){
                    infoMat <- infoMat[-items,]
                }
                infoMat <- infoMat[order(infoMat[,1],decreasing = T),]
                selectedItem <- infoMat[1,2]
                p <- Probs3plm(thetas = thetas[i],a[selectedItem],
                               b[selectedItem],
                               c[selectedItem])
                I[i,j] <- selectedItem
                U[i,j] <- sample(0:1,1,prob = c((1-p),p))
                irvs <- na.omit(U[i,])
                items <- na.omit(I[i,])
                theta.temp <- MAP(irvs,a[items],b[items])
                theta.out[i,j] <- theta.temp
                theta.hat[i] <- theta.temp
            }
            if(method == "PostPool"){
                whichWindow <- findInterval(theta.hat[i],edges)
                whichForm <- sample(nForms,1)
                windowItems <- rrr[[whichWindow]][[whichForm]]
                availableItems <- windowItems[which(!windowItems %in% I[i,j])]
                selectedItem <- sample(availableItems,1)
                p <- Probs3plm(thetas = thetas[i],a[selectedItem],
                               b[selectedItem],
                               c[selectedItem])
                I[i,j] <- selectedItem
                U[i,j] <- sample(0:1,1,prob = c((1-p),p))
                irvs <- na.omit(U[i,])
                items <- na.omit(I[i,])
                theta.temp <- MAP(irvs,a[items],b[items])
                theta.out[i,j] <- theta.temp
                theta.hat[i] <- theta.temp
            }
        }        
    }
    return(list(theta.out = theta.out,I = I, U = U))
}

n <- 5000
thetas <- rnorm(n)
res1 <- CatSim(thetas,a,b,c,mLength,edges,nForms,rrr,method = "MaxInfo")
res2 <- CatSim(thetas,a,b,c,mLength,edges,nForms,rrr,method = "PostPool")

png("ItemExposure.png")
barplot(table(as.vector(res1$I))/5000,ylim = c(0,1),main = "Item Exposure Frequency")
dev.off()

mean(res1$theta.out[,mLength] - thetas)
length(names(table(res1$I)))
max(table(res1$I)/5000)
hist(res1$theta.out[,mLength])
sqrt(mean((res1$theta.out[,mLength] - thetas)^2))

png("ItemExposure.png")
barplot(table(as.vector(res2$I))/5000,ylim = c(0,1),main = "Item Exposure Frequency")
dev.off()

mean(res2$theta.out[,mLength] - thetas)
length(names(table(res2$I)))
max(table(res2$I)/5000)
hist(res2$theta.out[,mLength])
sqrt(mean((res2$theta.out[,mLength] - thetas)^2))

rnorm(10)
for(i in 1:5000){
    if(i %% 100 == 0){
        Sys.sleep(.5)
        plot(res$theta.out[i,],type = "l",ylim = c(-3,3))
        abline(h = thetas[i])
    }
}

install.packages("/opt/gurobi751/linux64/R/gurobi_7.5-1_R_x86_64-pc-linux-gnu.tar.gz")
rnorm(1)
library(gurobi)
system(". ~/.bashrc")
system("echo hello from ~/.local_bashrc")
system("export PATH=${PATH}:/opt/gurobi751/linux64/")
system("echo $PATH")
system(". ~/.profile")

Sys.getenv("R_LIBS")
Sys.getenv("R_HOME")
.libPaths()
?.libPaths
.libPaths("/home/alex/R/x86_64-pc-linux-gnu-library/3.4")
model <- list()

model$A          <- matrix(c(1,2,3,1,1,0), nrow=2, ncol=3, byrow=T)
model$obj        <- c(1,1,2)
model$modelsense <- "max"
model$rhs        <- c(4,1)
model$sense      <- c('<', '>')
model$vtype      <- 'B'

params <- list(OutputFlag=0)

result <- gurobi(model, params)

print('Solution:')
print(result$objval)
print(result$x)
